/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package invoicingsystem;

import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.EventObject;
import javafx.scene.control.TextField;
import javax.swing.DefaultCellEditor;
import javax.swing.InputMap;
import javax.swing.JComponent;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;
import javax.swing.event.ChangeEvent;
import javax.swing.table.TableCellEditor;

/**
 *
 * @author d
 */
public class ModelEditableTable extends javax.swing.JTable {

    private TableInteractionListner tableInteractionListner;
    private boolean isCellEditableOnCellSelection;
    private boolean isCellBeingEditedWhileChanging;

    public boolean isCellEditableOnCellSelection() {
        return isCellEditableOnCellSelection;
    }

    public void setCellEditableOnCellSelection(boolean makeCellEditableOnCellSelection) {
        this.isCellEditableOnCellSelection = makeCellEditableOnCellSelection;
    }

    /**
     * Creates new form ModelEditableTable
     */
    public ModelEditableTable() {
        initComponents();


        ActionListener al = new ActionListener() {
            public void actionPerformed(ActionEvent e) {
            }
        };
//        this.registerKeyboardAction(al, KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
//        this.unregisterKeyboardAction(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0));
//        this.unregisterKeyboardAction(KeyStroke.getKeyStroke(KeyEvent.VK_UP));
        this.unregisterKeyboardAction(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0));
        InputMap im = getInputMap(JTable.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
        im.put(KeyStroke.getKeyStroke("DOWN"), "none");
        im.put(KeyStroke.getKeyStroke("UP"), "none");
        im.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0), "none");
        this.setSurrendersFocusOnKeystroke(true);
        setCellEditableOnCellSelection(true);
        getColumnModel().getColumn(0).setCellEditor(new mce(new JTextField()));

        this.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_ENTER) {
                    System.out.println("Enter pressed");
                }
                super.keyPressed(e);
            }
        });
        tableInteractionListner = new TableInteractionListner();
    }

    public void onBeforeEditStart() {
        int col = getEditingColumn();
        int row = getEditingRow();
        System.out.println(col + " be- " + row);
    }

    public void onAfterEditStart() {
        int col = getEditingColumn();
        int row = getEditingRow();
        System.out.println(col + " af- " + row);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null}
            },
            new String [] {
                "ID", "Name"
            }
        ));
        setCellSelectionEnabled(true);
        setRowHeight(24);
        setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    @Override
    public void changeSelection(int rowIndex, int columnIndex, boolean toggle, boolean extend) {

        super.changeSelection(rowIndex, columnIndex, toggle, extend);
        if (isCellEditableOnCellSelection) {
            System.out.println("selection changed " + rowIndex + "-" + columnIndex);
            isCellBeingEditedWhileChanging = true;
            editCellAt(rowIndex, columnIndex);
            isCellBeingEditedWhileChanging=false;
        }
    }

    @Override
    public boolean editCellAt(int row, int column) {
        boolean edit = super.editCellAt(row, column);
        System.out.println("editing started changed " + row + "-" + column);
        return edit;
    }

    @Override
    public boolean editCellAt(int row, int column, EventObject e) {
//        onBeforeEditStart();
        if (!this.isCellSelected(row, column)) {
            return false;
        }
        boolean edit = super.editCellAt(row, column, e);
//        onAfterEditStart();
//        System.out.println("0000000000000000000");
        return edit;
    }

    @Override
    public void editingCanceled(ChangeEvent e) {
        super.editingCanceled(e);
    }

    @Override
    public void editingStopped(ChangeEvent e) {

        int col = getEditingColumn();
        int row = getEditingRow();
        super.editingStopped(e);
        if(!isCellBeingEditedWhileChanging){
            col = convertColumnIndexToModel(col);
            row = convertRowIndexToModel(row);
        System.out.println("editing stopped " + row + "-" + col);

        if (col < getColumnCount() - 1 && row < getRowCount()) {
            changeSelection(row, ++col, false, false);
        } else if (col == getColumnCount() - 1 && row < getRowCount() - 1) {
            changeSelection(++row, 0, false, false);
        }
        }
        



    }

    @Override
    public TableCellEditor getCellEditor() {
        return super.getCellEditor();
    }

    class mce extends DefaultCellEditor {

        TableInteractionListner listner;
        JTextField txt ;

        public mce(final JTextField textField) {
            super(textField);
            textField.addKeyListener(new KeyAdapter() {
                @Override
                public void keyReleased(KeyEvent e) {
                    JTable tbl = ModelEditableTable.this;
                    ModelEditableTable.this.setValueAt(textField.getText(), tbl.getEditingRow(), tbl.getEditingColumn());
                    System.out.println(tbl.getValueAt(tbl.getEditingRow(), tbl.getEditingColumn()));
                }
            });
        }

        @Override
        public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
            txt=(JTextField) super.getTableCellEditorComponent(table, value, isSelected, row, column);
            SwingUtilities.invokeLater(new Runnable() {

                @Override
                public void run() {
                    txt.selectAll();
                    System.out.println("**********selecte all the text "+txt.getSelectedText());
               txt.requestFocus();
                }
            });
            return txt;
        }

        @Override
        public boolean stopCellEditing() {

            if (listner != null && !listner.validateCell()) {
                return false;
            }
            return super.stopCellEditing();
        }
    }
}

class TableInteractionListner {

    public void onCellStartEdit() {
    }

    public void onCellEditCompleted() {
    }

    public void onCellBeforeSelection() {
    }

    public boolean validateCell() {
        return true;
    }

    public void moveSelection() {
    }
}